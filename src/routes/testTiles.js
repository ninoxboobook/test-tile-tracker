const express = require('express');
const { Op } = require('sequelize');
const multer = require('multer');
const { S3Client, PutObjectCommand, DeleteObjectCommand } = require('@aws-sdk/client-s3');
const { getSignedUrl } = require('@aws-sdk/s3-request-presigner');
const { TestTile, ClayBody, Decoration } = require('../models');
const { isAuthenticated, isResourceOwner } = require('../middleware/auth');
const router = express.Router();

// Configure AWS S3
const s3Client = new S3Client({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  },
});

// Configure multer for file uploads
const upload = multer({
  storage: multer.memoryStorage(),
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB limit
  },
  fileFilter: (req, file, cb) => {
    if (file.mimetype.startsWith('image/')) {
      cb(null, true);
    } else {
      cb(new Error('Only image files are allowed'));
    }
  },
});

// Apply authentication middleware to all routes
router.use(isAuthenticated);

// Get all test tiles for the current user
router.get('/', async (req, res, next) => {
  try {
    const tiles = await TestTile.findAll({
      where: { userId: req.user.id },
      include: [
        { model: ClayBody, attributes: ['name'] },
        { model: Decoration, attributes: ['name'] }
      ],
      order: [['dateCreated', 'DESC']]
    });
    res.json(tiles);
  } catch (error) {
    next(error);
  }
});

// Search test tiles
router.get('/search', async (req, res, next) => {
  try {
    const { query, clayBodyId, decorationId } = req.query;
    const where = {
      userId: req.user.id
    };

    if (query) {
      where[Op.or] = [
        { tileId: { [Op.iLike]: `%${query}%` } },
        { notes: { [Op.iLike]: `%${query}%` } }
      ];
    }

    if (clayBodyId) {
      where.clayBodyId = clayBodyId;
    }

    if (decorationId) {
      where.decorations = {
        [Op.contains]: [{ decorationId }]
      };
    }

    const tiles = await TestTile.findAll({
      where,
      include: [
        { model: ClayBody, attributes: ['name'] },
        { model: Decoration, attributes: ['name'] }
      ],
      order: [['dateCreated', 'DESC']]
    });

    res.json(tiles);
  } catch (error) {
    next(error);
  }
});

// Get a single test tile
router.get('/:id', isResourceOwner(TestTile), async (req, res, next) => {
  try {
    const tile = await TestTile.findByPk(req.resource.id, {
      include: [
        { model: ClayBody },
        { model: Decoration }
      ]
    });
    
    // Generate signed URLs for photos
    if (tile.photoUrls) {
      const signedUrls = await Promise.all(
        tile.photoUrls.map(async (key) => {
          const command = new GetObjectCommand({
            Bucket: process.env.AWS_BUCKET_NAME,
            Key: key
          });
          return getSignedUrl(s3Client, command, { expiresIn: 3600 });
        })
      );
      tile.setDataValue('signedPhotoUrls', signedUrls);
    }
    
    res.json(tile);
  } catch (error) {
    next(error);
  }
});

// Create a new test tile
router.post('/', async (req, res, next) => {
  try {
    const { isAutoGenerated } = req.body;
    let tileId = req.body.tileId;

    if (isAutoGenerated) {
      tileId = await req.user.getNextAutoId();
    }

    const tile = await TestTile.create({
      ...req.body,
      tileId,
      userId: req.user.id
    });

    res.status(201).json(tile);
  } catch (error) {
    next(error);
  }
});

// Update a test tile
router.put('/:id', isResourceOwner(TestTile), async (req, res, next) => {
  try {
    const tile = req.resource;
    await tile.update(req.body);
    res.json(tile);
  } catch (error) {
    next(error);
  }
});

// Delete a test tile
router.delete('/:id', isResourceOwner(TestTile), async (req, res, next) => {
  try {
    const tile = req.resource;
    
    // Delete photos from S3
    if (tile.photoUrls) {
      await Promise.all(
        tile.photoUrls.map(async (key) => {
          const command = new DeleteObjectCommand({
            Bucket: process.env.AWS_BUCKET_NAME,
            Key: key
          });
          return s3Client.send(command);
        })
      );
    }
    
    await tile.destroy();
    res.status(204).end();
  } catch (error) {
    next(error);
  }
});

// Upload photos for a test tile
router.post('/:id/photos', isResourceOwner(TestTile), upload.array('photos', 5), async (req, res, next) => {
  try {
    const tile = req.resource;
    const uploadedUrls = [];

    // Upload files to S3
    for (const file of req.files) {
      const key = `tiles/${tile.id}/${Date.now()}-${file.originalname}`;
      const command = new PutObjectCommand({
        Bucket: process.env.AWS_BUCKET_NAME,
        Key: key,
        Body: file.buffer,
        ContentType: file.mimetype
      });

      await s3Client.send(command);
      uploadedUrls.push(key);
    }

    // Update tile with new photo URLs
    const currentUrls = tile.photoUrls || [];
    await tile.update({
      photoUrls: [...currentUrls, ...uploadedUrls]
    });

    res.json(tile);
  } catch (error) {
    next(error);
  }
});

// Delete a photo from a test tile
router.delete('/:id/photos/:photoIndex', isResourceOwner(TestTile), async (req, res, next) => {
  try {
    const tile = req.resource;
    const photoIndex = parseInt(req.params.photoIndex);

    if (!tile.photoUrls || photoIndex >= tile.photoUrls.length) {
      return res.status(404).json({ error: 'Photo not found' });
    }

    const photoKey = tile.photoUrls[photoIndex];

    // Delete from S3
    const command = new DeleteObjectCommand({
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: photoKey
    });
    await s3Client.send(command);

    // Update tile
    const newPhotoUrls = [...tile.photoUrls];
    newPhotoUrls.splice(photoIndex, 1);
    await tile.update({ photoUrls: newPhotoUrls });

    res.json(tile);
  } catch (error) {
    next(error);
  }
});

// Get related test tiles
router.get('/:id/related', isResourceOwner(TestTile), async (req, res, next) => {
  try {
    const tile = req.resource;
    
    // Find tiles with the same clay body or decorations
    const relatedTiles = await TestTile.findAll({
      where: {
        userId: req.user.id,
        id: { [Op.ne]: tile.id },
        [Op.or]: [
          { clayBodyId: tile.clayBodyId },
          {
            decorations: {
              [Op.overlap]: tile.decorations.map(d => d.decorationId)
            }
          }
        ]
      },
      include: [
        { model: ClayBody, attributes: ['name'] },
        { model: Decoration, attributes: ['name'] }
      ]
    });

    // Calculate relevance scores
    const scoredTiles = relatedTiles.map(relatedTile => {
      let score = 0;
      
      // Same clay body
      if (relatedTile.clayBodyId === tile.clayBodyId) {
        score += 1;
      }
      
      // Common decorations
      const commonDecorations = tile.decorations.filter(d1 =>
        relatedTile.decorations.some(d2 => d1.decorationId === d2.decorationId)
      ).length;
      score += commonDecorations;

      return {
        ...relatedTile.toJSON(),
        relevanceScore: score
      };
    });

    // Sort by relevance score
    scoredTiles.sort((a, b) => b.relevanceScore - a.relevanceScore);

    res.json(scoredTiles);
  } catch (error) {
    next(error);
  }
});

module.exports = router;
